---
tags: []
title: Practical ansible
description: Let's see how we can write some common security playbooks for our
  ubuntu servers
date: 31th Aug 2025
image: /blog-images/cows.webp
draft: true
---

For getting taste of Ansible, Here i try to write some ansible playbooks for common security tasks. Here are the things that i think achievable with ansible:

1. Copy our ssh public key to all the remote servers, so we can connect to all servers without using password login
2. security updates
3. disabling password login
4. Firewall configuration
5. Changing the ssh port from 22 to something else. humans are smart enough to find that, we're doing this only for getting rid of some robots that are wandering the internet for finding insecure servers.(I know, some robots are also not that dumb but anyway)

Let's Go!

## Base templete

Our playbook can be a single file like this:

```yaml
- name: General Linux security hardening
  hosts: all
  become: true
  gather_facts: true
  remote_user: userblahblah
  tasks:
  - name: Ensure apache is at the latest version
    ansible.builtin.yum:
      name: httpd
      state: latest

  - name: Write the apache config file
    ansible.builtin.template:
      src: /srv/httpd.j2
      dest: /etc/httpd.conf

  - name: Ensure postgresql is at the latest version
    ansible.builtin.yum:
      name: postgresql
      state: latest

  - name: Ensure that postgresql is started
    ansible.builtin.service:
      name: postgresql
      state: started
```

But, without structuring your **ansible tasks** into seperate files, you will end up with long playbooks which is hard to maintain.

So you will be better off using `import_tasks` in tasks section:

```yaml
- name: General Linux security hardening
  hosts: all
  become: true
  gather_facts: true
  remote_user: userblahblah
  tasks:
    -  import_tasks: tasks/authorized_keys.yml
    -  import_tasks: tasks/disable_root_login.yml
  handlers:
    - import_tasks: handler/restart_ssh.yml
```

the address `tasks/**` is relative the playbook folder. `tasks` directory is where you define your tasks. (And they can be used in another playbooks as well)

You may wonder what is the field `handlers` doing here. Sometimes you want a task to run only when a change is made on a machine. For example, you may want to restart a service if a task updates the configuration of that service, but not if the configuration is unchanged. Ansible uses handlers to address this use case. Handlers are tasks that only run when notified.

So using this setup, we are going define our tasks in next sections:

## SSH public key

Before disabling password login and doing anything like this, you need to put your public key in the remote servers so you can login using ssh key authentication method. Otherwise you will be locked out and something bad happens

Because this is so common, it has it's own dedicated simple module named `ansible.posix.authorized_key`. Let's create the file `tasks/authorized_key`:

```yaml
---
- name: Copy local public key to destination server
  ansible.posix.authorized_key:
    user: tommy
    state: present
    key: "{{ lookup('file', lookup('env', 'HOME') + '/.ssh/id_ed25519.pub') }}"

```

we use the module `ansible.posix.authorized_key` to move our public key to remote server. fields are quite self explanatory. in the `key` field, you need to put your public key string. but instead you usually use the `lookup` plugin to use external text files as a value. in the `lookup` function call, we are trying to access our host's home directory using `$HOME` environment variable. and after that, we just concatenate that with `/.ssh/id_ed25519.pub` .

Define this task to your main playbook and run the playbook using the command `ansible-playbook` make sure it's doing it's job currectly. (Normally if the key is present in remote server, nothing should happen)

## Security update

Writing a task for automatically updating the security patches through `aptitude` would be really helpful and time saving.

::info
Writing ansible tasks for this purpose is fine, but there is also another option for applying security patches which is using the apt package unattended upgrade. It fits better to the aptitude package manager system. And also you don't need to do anything manually.
::

Create the file `tasks/apt_security.yml` :

```yaml
- name: Update all packages to their latest version
  ansible.builtin.apt:
    name: "*"
    state: latest
    update_cache: true
    only_upgrade: true

```

We don't need to be too specific here. We just put the star as a package name and all packages will be upgraded to the latest patch version. The `update_cache` field will make sure the cache is updated before upgrade process.

::info
It's needless to say, we are using Ubuntu LTS and the package major versions are frozen in the entire support time-span (for 5 years).
::

## Disable root login

Servers that are reachable from the public internet, needs to be reinforced for dealing with bad actors such as **hackers** and **automated robots**.

::info
Check your `auth.log` file for any suspicious activity.
::

You have some common options to configure:

- Disabling the ssh `root` Login
- Disabling the ssh password-login completely
- Configuring something like `fail2ban`

::info
All approaches for human authentication rely on: **Something You Know, Have, or Are.** But the thing is, knowing something good enough like complex password is not feasible for most of us. Especially when you are dealing with multiple machines. So you better to leverage something that you can **have**. Something like ssh-keys.
::

Here we just define the first one. It's probably the easiest and most straight-forward things to do.

The built-in module `ansible.builtin.lineinfile` can help us here:

```yaml
---
- name: Disabling the root login of ssh daemon
  ansible.builtin.lineinfile:
    path: /etc/ssh/sshd_config
    state: present
    regex: '^#?PermitRootLogin\s+.*'
    line: 'PermitRootLogin no'
  notify:
    - ssh daemon reload
```

The module `lineinfile` need the `path` of the file, `regex` to match and the `line` to replace into the matched regex.

::info
When modifying a line, the regex should typically match both the initial state of the line as well as its state after replacement by `line` to ensure idempotence.
::

At the end, we notify the `ssh daemon reload` to apply the new configuration. Here is the handler in `handler/restart_ssh.yml` :

```yaml
---
- name: restart ssh service
  ansible.builtin.service:
    name: ssh.socket
    state: restarted
```

## Firewall

You better to be strict about what packets are free to enter you server.

The common sense of firewall strategies are allowing only the packets that you are need and trust. You canâ€™t have serious security if you use a default policy of ACCEPT and continuously insert rules to drop packets from sources that start to send bad stuff. You must allow only the packets that you trust, and deny everything else.

So, the firewalls are little more specific because it depends on the applications that you are running and hosting on your server.

Here I write some general ones in the playbook

::info
Iptable is still the dominant firewall in most Linux distros and because of that, We will focus on that here.
::

::info
Don't do anything rush about iptables otherwise you will lock-out yourself from connecting to your server. Try to test these using tools like `iptables-apply` to see if they work as you want.
::

```yaml
---
- name: flush all INPUT chain rules
  ansible.builtin.iptables:
    chain: INPUT
    flush: yes

- name: Iptable accept icmp packets
  ansible.builtin.iptables:
    chain: INPUT
    protocol: icmp
    jump: ACCEPT

- name: Iptable accept tcp packet that are initiated from server
  ansible.builtin.iptables:
    chain: INPUT
    protocol: tcp
    syn: negate
    jump: ACCEPT

- name: Iptable accept packets from localhost
  ansible.builtin.iptables:
    chain: INPUT
    source: 127.0.0.1
    jump: ACCEPT

- name: Iptable accept packets from local network
  ansible.builtin.iptables:
    chain: INPUT
    source: 10.0.0.0/24
    jump: ACCEPT

- name: Iptable accept tcp packets on port 22
  ansible.builtin.iptables:
    chain: INPUT
    protocol: tcp
    destination_ports:
      - "22"
    jump: ACCEPT

- name: Iptable accept dns packets
  ansible.builtin.iptables:
    chain: INPUT
    protocol: udp
    source_port: 53
    jump: ACCEPT

- name: Iptable accept on http port
  ansible.builtin.iptables:
    chain: INPUT
    protocol: tcp
    destination_port: 80
    jump: ACCEPT

- name: Iptable accept requests to k3s control node, Only from local network.
  ansible.builtin.iptables:
    chain: INPUT
    source: 10.0.0.0/24
    protocol: tcp
    destination_port: 6443
    jump: ACCEPT

- name: INPUT CHAIN Default Policy Drop
  ansible.builtin.iptables:
    chain: INPUT
    policy: DROP

- name: Save current state of the firewall in file system
  community.general.iptables_state:
    state: saved
    path: /etc/iptables/rules.v4
```

Things are quite self-explanatory. But the important thing is, you need to make sure the iptable is saved and preserved after reboot. This can be done via the package `iptable-persistant` . You just install the package and after that, the file `/etc/iptabels/rules.v4` will be loaded every-time at the boot.

::info
UFW can also be used as a more ergonomic front-end to iptables here. It's roles also does not need configuring to be persistant after reboot. It just works!
::

## SSH port

## Wrap up

As you seen, Ansible has a really important place for automation In devops tool era. It's performant and ergonomic for writing common tasks. But as a downside, it's tedious to write and test properly. And also playbooks can become nasty for some tricky tasks like changing the ssh port and etc. Anyway, i'm happy with that.
